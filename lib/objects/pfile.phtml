<?php
    /******************************************************************
     pfile.phtml                                           Muze Ariadne
     ------------------------------------------------------------------
     Author: Muze (info@muze.nl)
     Date: 31 october 2002

     Copyright 2002 Muze

     This file is part of Ariadne.

     Ariadne is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published 
     by the Free Software Foundation; either version 2 of the License, 
     or (at your option) any later version.
 
     Ariadne is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with Ariadne; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  
     02111-1307  USA

    -------------------------------------------------------------------

     Class inheritance: 	pobject > pfile
     Description:

       This is the class definition file of the pfile class.

    ******************************************************************/

require_once(AriadneBasePath."/objects/pobject.phtml");
require_once(AriadneBasePath."/modules/mod_url.php");
require_once(AriadneBasePath."/modules/mod_mimemagic.php");

class pfile extends pobject { // pfile class definition
	function GetFile() {
		$this->pushContext( Array( "arCurrentObject" => $this));
		$ret = ar_store_files::get();
		if ( !ar_error::isError($ret) ) {
			$ret = $ret->getContents();
		} else {
			$ret = null; //backwards compatibility... there was no error checking before
		}
		$this->popcontext();
		return $ret;
	}

	function ExistsFile() {
		$this->pushContext( Array( "arCurrentObject" => $this));
		$ret = ar_store_files::exists();
		$this->popcontext();
		return $ret;
	}

	function ParseFile() {
		return $this->ParseString( $this->GetFile() );
	}

	function ParseString($filecontent) {
		$this->pushContext( Array( "arCurrentObject" => $this));
		$res = URL::ARtoRAW($filecontent, true);
		$this->popcontext();
		return $res;
	}

	function ShowFile($mimetype='') {
		global $AR, $ARCurrent, $ARnls;
		$this->pushContext( Array( "arCurrentObject" => $this));
		$file = ar_store_files::get();
		if ( ar_error::isError($file) ) {
			$this->popcontext();
			return $file;
		}
		if ( !$mimetype && isset($this->data->mimetype) ) {
			$mimetype = $this->data->mimetype;
		}
		if ( !$mimetype ) {
			$temp = ar_store_files::temp($file);
			$temp_file_meta  = $temp->getMetaData();
			$mimetype = get_mime_type($temp_file_meta['uri']);
		}

		if ($mimetype && function_exists("get_content_type")) {
			$mimetype = get_content_type($mimetype, basename($this->path));
		}
		if (!$ARCurrent->arDontCache && $ARCurrent->cacheCallChainSettings[$this->id]['serverCache'] != -1 && $this->CheckPublic('read')) {
			$ARCurrent->cacheCallChainSettings[$this->id]['serverCache'] = -2;
		}
		$template = $this->getvar("arCallFunction");
		if (!$template || $template == "view.html") {
			$filename = basename($this->path);
		}
		if (!preg_match("|^text/|", $mimetype)) {
			$size = $file->size();
		}

		if (ldSetContent($mimetype, $size)) {
			$cacheseconds=1800; // 1/2 hour
			$expires=time()+$cacheseconds;
			if (!$ARCurrent->arDontCache) {
				if ($AR->user->data->login=="public" || $this->CheckPublic("read")) {
					// always set the client side cache headers, independant of
					// server side cache configuration. Except for private content
					// (needed to prevent proxies from caching it too). If server 
					// side caching is on, the loader will override this header.
					ldSetClientCache(true, $expires);
				}
			}
		} else if(!preg_match("|^text/|", $mimetype)) {
			return ar_error::raiseError( sprintf( $ARnls["err:headerssentnottext"], $this->path ), 501 );
		}
		if ($filename) {
			ldHeader("Content-Disposition: inline; filename=$filename");
		}
		if ($mimetype=="text/html") { // parse {arRoot}
			// assume html files to use charset UTF-8; this will always work correctly
			// with the MSIE html editor, and won't corrupt 'normal' html.
			// ldHeader("Content-Type: text/html; charset=UTF-8");
			echo $this->ParseString($file->getContents());
		} else {
			// ldHeader("Content-Type: $mimetype");
			// set pragma: cache; bug workaround for internet explorer and https
			if (ldGetServerVar('HTTPS')) {
				ldHeader('Pragma: cache');
			}
			$file->readfile();
		}
		$this->popcontext();
	}

	function DownloadFile($filename=false) {
		global $ARCurrent, $ARnls;
		$this->pushContext( Array( "arCurrentObject" => $this));
		$file = ar_store_files::get();
		if ( ar_error::isError($file) ) {
			$this->popcontext();
			return $file;
		}
		if (!$ARCurrent->arDontCache && $ARCurrent->cachetime!=-1 && $this->CheckPublic('read')) {
			$ARCurrent->cachetime=-2; // set cache to onchange
		}
		$size=$file->size();
		if (!$filename) {
			$filename = substr($this->path, strlen($this->parent), -1);
		}
		ldHeader('Cache-Control: private');
		// set pragma: cache; bug workaround for internet explorer and https
		if (ldGetServerVar('HTTPS')) {
			ldHeader('Pragma: cache');
		} else {
			ldHeader('Pragma: no-cache');
		}
		if (!ldHeader("Content-type: application/x-ariadne-download")) {
			return ar_error::raiseError( sprintf( $ARnls["err:headerssentnottext"], $this->path ), 501 );
		} else {
			ldHeader("Content-Disposition: attachment; filename=\"".$filename."\"");
			ldHeader("Content-length:".(string)$size);
			$file->readfile();
		}
		$this->popcontext();
	}

	function SaveFile($contents, $mimetype=false) {
		$result="";
		$name=preg_replace("|[\\\/]|","",$name); // make sure nobody gets /etc/passwd
		if ($name) {
			if (!$this->arIsNewObject && $this->CheckSilent('edit')) {
				$this->pushContext( Array( "arCurrentObject" => $this));
				$ret = ar_store_files::save($contents);
				$this->popcontext();
				return $ret;
			} else if ($this->arIsNewObject && $this->CheckSilent('add','pfile')) {
				// new pfile, so it has no id yet, use the tempfile
				$result = Array();

				// fake an uploaded file, put it in the normal temp dir
				$file_artemp=tempnam($this->store->get_config("files")."temp","upload");
				if ($fp=fopen($file_artemp, "wb")) {
					$result=fwrite($fp, $contents);
					fclose($fp);
				}

				// now make the new values available to system.save.data.phtml
				$info[$name]=$this->data->name;
				$info[$name."_temp"]=substr($file_artemp,strlen($this->store->get_config("files")."temp"));
				$info[$name."_size"]=strlen($contents);
				if (!$mimetype) {
					require_once($this->store->get_config('code')."modules/mod_mimemagic.php");
					$type = get_mime_type($file_artemp);
				} else {
					$type = $mimetype;
				}
				$info[$name."_type"]=$type;
				$info['mimetype']=$type;
				$_POST = array_merge($_POST, $info);

				return $info;
			}
		} else {
			return false;
		}
	}

	function _ParseString($content) {
		return $this->ParseString($content);
	}

	function _ParseFile() {
		return $this->ParseFile();
	}
  
	function _ExistsFile() {
		return $this->ExistsFile();
	}

	function _GetFile() {
		return $this->GetFile();
	}
  
	function _ShowFile($mimetype='') {
		return $this->ShowFile($mimetype);
	}

	function _DownloadFile($filename=false) {
		return $this->DownloadFile($filename);
	}
	
	function _SaveFile($contents, $mimetype=false) {
		return $this->SaveFile($contents, $mimetype);
	}
  
} // end of pfile class definition
